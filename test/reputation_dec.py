from Crypto.PublicKey import RSA
from Crypto.Util.number import bytes_to_long
import random
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256
class PCA:
    """
    Pseudonym Certification Authority (PCA) responsible for issuing and signing certified pseudonyms.
    """
    def __init__(self):
        self.key = RSA.generate(2048)  # PCA's RSA key for signing
        self.n = self.key.n  # RSA modulus
        self.e = self.key.e  # RSA public exponent
        self.issued_certificates = {}  # Track issued pseudonyms

    def sign_blinded_pseudonym(self, blinded_pseudonym):
        """
        Sign a blinded pseudonym for a user.
        """
        signed_blinded_pseudonym = pow(blinded_pseudonym, self.key.d, self.n)
        return signed_blinded_pseudonym

    def issue_pseudonym(self, user, time_slot):
        """
        Issue a certified pseudonym to a user for a specified time slot.
        """
        if (user.real_identity, time_slot) in self.issued_certificates:
            raise Exception("Pseudonym for this user and time slot already issued.")
        
        pseudonym = user.generate_pseudonym(time_slot)
        blinded_pseudonym = user.blind_pseudonym(pseudonym)
        signed_blinded_pseudonym = self.sign_blinded_pseudonym(blinded_pseudonym)
        user.receive_signed_pseudonym(signed_blinded_pseudonym)

        # Register issued pseudonym
        self.issued_certificates[(user.real_identity, time_slot)] = pseudonym
        print(f"Pseudonym for user {user.real_identity} issued for time slot {time_slot}.")

    def verify_pseudonym(self, pseudonym, signed_pseudonym):
        """
        Verify the signed pseudonym to check if it is valid.
        """
        # Check if the signed pseudonym corresponds to the original pseudonym
        is_valid = pow(signed_pseudonym, self.e, self.n) == pseudonym
        return is_valid

    def verify_reputation_declaration(self, reputation_declaration, reputation_info,Cipi_user , pi_signed_pseudonym):

        Cipi, signed_reputation_info = reputation_declaration
        if not self.verify_pseudonym(Cipi_user[0] , pi_signed_pseudonym):
            print("User B pseudonym has problem!!")
        else :
            print("User B pseudonym Verified Correctly!!")

        if Cipi == Cipi_user:  # Compare CipiA and CipiB
            print("Reputation was self-generated by User B.")
            return False
        
        # Step 3: Verify the signature of the reputation information (τpiA →piB)
        is_valid_reputation = self.verify_reputation_signature(signed_reputation_info, reputation_info , Cipi[1])
        if not is_valid_reputation:
            print("Failed to verify reputation information signature.")
            return False
        
        return True

    def verify_reputation_signature(self, signed_reputation_info, reputation_info,public_key):
        """
        Verify the signature of the reputation information (τpiA →piB) using the public key of User A.
        """
        hash_message = SHA256.new(reputation_info)
        try:
            pkcs1_15.new(public_key).verify(hash_message, signed_reputation_info)
            print("The signature is valid. Message integrity and authenticity confirmed.")
            return True 
        except (ValueError, TypeError):
            print("The signature is invalid. Message integrity compromised.")
            return False 

        # The signature verification involves checking if the reputation info corresponds to the signed value
        # Here, we simulate by directly comparing the values
        # is_valid = signed_reputation_info == reputation_info

class User:
    """
    User class representing a network participant with a real identity and pseudonyms.
    """
    def __init__(self, real_identity, pca):
        self.real_identity = real_identity
        self.pca = pca
        self.rsa_key = RSA.generate(2048)  # User's RSA key for signing reputation information
        self.n = pca.n  # PCA's modulus
        self.e = pca.e  # PCA's public exponent
        self.pseudonyms = {}  # Store pseudonyms per time slot
        self.signed_pseudonym = None
        self.private_key = self.rsa_key
        self.public_key = self.rsa_key.publickey()

    def generate_pseudonym(self, time_slot):
        """
        Generate a unique pseudonym for a specific time slot.
        """
        pseudonym = f"pseudonym_{self.real_identity}_{time_slot}"
        pseudonym_number = bytes_to_long(pseudonym.encode())
        self.pseudonyms[time_slot] = pseudonym_number
        return pseudonym_number

    def blind_pseudonym(self, pseudonym):
        """
        Blind the pseudonym using a random blinding factor.
        """
        while True:
            self.r = random.randrange(1, self.n)
            if self.r % self.n != 0:
                break
        self.r_inv = pow(self.r, -1, self.n)  # modular inverse of r mod n
        blinded_pseudonym = (pseudonym * pow(self.r, self.e, self.n)) % self.n
        return blinded_pseudonym

    def receive_signed_pseudonym(self, signed_blinded_pseudonym):
        """
        Unblind the signed pseudonym received from the PCA.
        """
        # Unblind the pseudonym to obtain the signature on the original pseudonym
        self.signed_pseudonym = (signed_blinded_pseudonym * self.r_inv) % self.n
        print(f"User {self.real_identity} received signed pseudonym.")

    def sign_reputation_info(self, reputation_info):
        """
        Sign reputation information with the user's private key.
        """
        print("reputation info = ", reputation_info)
        
        hash_message = SHA256.new(reputation_info)
        
        signature = pkcs1_15.new(self.private_key).sign(hash_message)
        
        return signature

    def create_reputation_declaration(self, reputation_info, time_slot):
        """
        Create a reputation declaration for another user.
        """
        
        Cipi = (self.pseudonyms[time_slot], self.public_key, time_slot)
        
        signed_reputation = self.sign_reputation_info(reputation_info)
        reputation_declaration = (Cipi, signed_reputation)
        print(f"Reputation declaration created.")
        return reputation_declaration
    
    
    def send_for_verification(self, time_slot):
        """
        Send pseudonym and signed pseudonym to PCA for verification.
        """
        pseudonym = self.pseudonyms[time_slot]
        return self.pca.verify_pseudonym(pseudonym, self.signed_pseudonym)


# Example usage:
# Initialize PCA (Pseudonym Certification Authority)
pca = PCA()

# Create Users with a unique real identity and link to the PCA
user_a = User("UserA_RealID", pca)
user_b = User("UserB_RealID", pca)

# Issue a pseudonym for User A (time slot 4) and User B (time slot 5)
time_slot = 4
pca.issue_pseudonym(user_a, time_slot)
pca.issue_pseudonym(user_b, time_slot)

# User requests verification of their pseudonym for the specified time slot
if user_a.send_for_verification(time_slot):
    print("The pseudonym is valid.")
else:
    print("The pseudonym is invalid.")

# User A gives a dummy rating to User B (e.g., a simple rating value)
reputation_info = b'Good reputation for UserB'
# User A creates a reputation declaration for User B
reputation_declaration = user_a.create_reputation_declaration( reputation_info, time_slot)
# Verify the reputation declaration by PCA
cipib = (user_b.pseudonyms[time_slot], user_b.public_key, time_slot)
is_valid = pca.verify_reputation_declaration(reputation_declaration, reputation_info, cipib, user_b.signed_pseudonym )
if is_valid:
    print("Reputation declaration is valid.")
else:
    print("Reputation declaration is invalid.")

