from Crypto.PublicKey import RSA
from Crypto.Util.number import bytes_to_long, long_to_bytes
import random
from Crypto.Signature import pkcs1_15
from Crypto.Hash import SHA256

class PCA:
    """
    Pseudonym Certification Authority (PCA) responsible for issuing and signing certified pseudonyms.
    """
    def __init__(self):
 
        with open('pca.pem', 'r') as key_file:
            private_key_pem = key_file.read()
        # Import fixed key from PEM
        self.key = RSA.import_key(private_key_pem)
        self.n = self.key.n  # RSA modulus
        self.e = self.key.e  # RSA public exponent
        self.issued_certificates = {}  # 
        self.private_key = self.key
        
    def sign_reputation_info(self, reputation_info):
        """
        Sign reputation information with the user's private key.
        """
        hash_message = SHA256.new(reputation_info)
        signature = pkcs1_15.new(self.private_key).sign(hash_message)
        return signature
    
    
    def sign_blinded_pseudonym(self, blinded_pseudonym):
        """
        Sign a blinded pseudonym for a user.
        """
        signed_blinded_pseudonym = pow(blinded_pseudonym, self.key.d, self.n)
        return signed_blinded_pseudonym

    def issue_pseudonym(self, user, time_slot):
        """
        Issue a certified pseudonym to a user for a specified time slot.
        """
        if (user.real_identity, time_slot) in self.issued_certificates:
            raise Exception("Pseudonym for this user and time slot already issued.")
        
        pseudonym = user.generate_pseudonym(time_slot)
        blinded_pseudonym = user.blind_pseudonym(pseudonym)
        signed_blinded_pseudonym = self.sign_blinded_pseudonym(blinded_pseudonym)
        user.receive_signed_pseudonym(signed_blinded_pseudonym)

        # Register issued pseudonym
        self.issued_certificates[(user.real_identity, time_slot)] = pseudonym
        print(f"Pseudonym for user {user.real_identity} issued for time slot {time_slot}.")

    def verify_pseudonym(self, pseudonym, signed_pseudonym):
        """
        Verify the signed pseudonym to check if it is valid.
        """
        # Check if the signed pseudonym corresponds to the original pseudonym
        is_valid = pow(signed_pseudonym, self.e, self.n) == pseudonym
        return is_valid

    def verify_reputation_declaration(self, reputation_declaration, reputation_info,Cipi_user , pi_signed_pseudonym):

        Cipi, signed_reputation_info = reputation_declaration
        if not self.verify_pseudonym(Cipi_user[0] , pi_signed_pseudonym):
            print("User B pseudonym has problem!!")
        else :
            print("User B pseudonym Verified Correctly!!")

        if Cipi == Cipi_user:  # Compare CipiA and CipiB
            print("Reputation was self-generated by User B.")
            return False
        
        # Step 3: Verify the signature of the reputation information (τpiA →piB)
        is_valid_reputation = self.verify_reputation_signature(signed_reputation_info, reputation_info , Cipi[1])
        if not is_valid_reputation:
            print("Failed to verify reputation information signature.")
            return False
        
        return True

    def verify_reputation_signature(self, signed_reputation_info, reputation_info,public_key):
        """
        Verify the signature of the reputation information (τpiA →piB) using the public key of User A.
        """
        hash_message = SHA256.new(reputation_info)
        try:
            pkcs1_15.new(public_key).verify(hash_message, signed_reputation_info)
            print("The signature is valid. Message integrity and authenticity confirmed.")
            return True 
        except (ValueError, TypeError):
            print("The signature is invalid. Message integrity compromised.")
            return False 

    def sign_blinded_trv(self, blinded_trv):
        """
        Sign a blinded pseudonym for a user.
        """
        signed_blinded_pseudonym = pow(blinded_trv, self.key.d, self.n)
        return signed_blinded_pseudonym
        # The signature verification involves checking if the reputation info corresponds to the signed value
        # Here, we simulate by directly comparing the values
        # is_valid = signed_reputation_info == reputation_info

    
    
    def verify_trv(self, trv, signed_trv):
        """
        Verify the signed pseudonym to check if it is valid.
        """
        # Check if the signed pseudonym corresponds to the original pseudonym
        is_valid = pow(signed_trv, self.e, self.n) == trv
        return is_valid

class User:
    """
    User class representing a network participant with a real identity and pseudonyms.
    """
    def __init__(self, real_identity, pca):
        self.real_identity = real_identity
        self.pca = pca
        self.rsa_key = RSA.generate(2048)  # User's RSA key for signing reputation information
        self.n = pca.n  # PCA's modulus
        self.e = pca.e  # PCA's public exponent
        self.pseudonyms = {}  # Store pseudonyms per time slot
        self.signed_pseudonym = None
        self.private_key = self.rsa_key
        self.public_key = self.rsa_key.publickey()

    def generate_pseudonym(self, time_slot):
        """
        Generate a unique pseudonym for a specific time slot.
        """
        pseudonym = f"pseudonym_{self.real_identity}_{time_slot}"
        pseudonym_number = bytes_to_long(pseudonym.encode())
        self.pseudonyms[time_slot] = pseudonym_number
        return pseudonym_number

    def blind_pseudonym(self, pseudonym):
        """
        Blind the pseudonym using a random blinding factor.
        """
        while True:
            self.r = random.randrange(1, self.n)
            if self.r % self.n != 0:
                break
        self.r_inv = pow(self.r, -1, self.n)  # modular inverse of r mod n
        blinded_pseudonym = (pseudonym * pow(self.r, self.e, self.n)) % self.n
        return blinded_pseudonym



    def receive_signed_pseudonym(self, signed_blinded_pseudonym):
        """
        Unblind the signed pseudonym received from the PCA.
        """
        # Unblind the pseudonym to obtain the signature on the original pseudonym
        self.signed_pseudonym = (signed_blinded_pseudonym * self.r_inv) % self.n
        print(f"User {self.real_identity} received signed pseudonym.")

    def sign_reputation_info(self, reputation_info):
        """
        Sign reputation information with the user's private key.
        """
        hash_message = SHA256.new(reputation_info)
        signature = pkcs1_15.new(self.private_key).sign(hash_message)
        return signature

    def create_reputation_declaration(self, reputation_info, time_slot):
        """
        Create a reputation declaration for another user.
        """
        Cipi = (self.pseudonyms[time_slot], self.public_key, time_slot)
        # print("hello")
        
        signed_reputation = self.sign_reputation_info(reputation_info)
        reputation_declaration = (Cipi, signed_reputation)
        print(f"Reputation declaration created.")
        return reputation_declaration
    
    
    def send_for_verification(self, time_slot):
        """
        Send pseudonym and signed pseudonym to PCA for verification.
        """
        pseudonym = self.pseudonyms[time_slot]
        return self.pca.verify_pseudonym(pseudonym, self.signed_pseudonym)

    def blind_TRV(self, trv):
        """
        Blind the pseudonym using a random blinding factor.
        """
        while True:
            self.r = random.randrange(1, self.n)
            if self.r % self.n != 0:
                break
        self.r_inv = pow(self.r, -1, self.n)  # modular inverse of r mod n
        blinded_pseudonym = (trv * pow(self.r, self.e, self.n)) % self.n
        return blinded_pseudonym
    def unblind_trv_sign(self, signed_blinded_trv):
        """
        Unblind the signed pseudonym received from the PCA.
        """
        # Unblind the pseudonym to obtain the signature on the original pseudonym
        return (signed_blinded_trv * self.r_inv) % self.n

# Example usage:
# Initialize PCA (Pseudonym Certification Authority)
# pca = PCA()

# # Create a user with a unique real identity and link to the PCA


# user = User("UserA_RealID", pca)

# # Issue a pseudonym for a specific time slot
# time_slot = 4
# pca.issue_pseudonym(user, time_slot)


# # User requests verification of their pseudonym for the specified time slot
# if user.send_for_verification(time_slot):
#     print("The pseudonym is valid.")
# else:
#     print("The pseudonym is invalid.")
